Graph with 37,700 Nodes and 289,003 edges.

Every Node will have 2 Queues:
    1) Wall Queue: Actions taken by that Node.
    2) Feed Queue: Actions taken by all neighbors.

Every Node also has a variable to store in which order to show the feed.
    value = 0 means according to priority of friends 
    value = 1 means feed would be shown chronologically

## How to maintain priority of friends?? (any ideas) ##

Threads:
    1) userSimulator: (Only 1 such thread)
        a) Three Actions possible: Post, Comment, Like.
        b) Randomly select 100 nodes.
        c) For Every Node, take N Actions where every action is randomly sampled from the three.
        d) Here, N is proportional to log2(DEGREE OF THE NODE).
        ## Thus N = k*(log2(DEGREE)) so here is k always constant or is this also supposed to be chosen randomly?? ##
        e) Push actions of a node to its wall queue.
        f) Push it in a queue to checked by pushUpdate Threads.
        "Will use lock while pushing to the queue" <-> L1
        g) Log in sns.log and print on terminal:
            ## How would this thread know (for print/logging purpose) the node selected by pushUpdate thread?
            i) Random nodes selected.
            ii) How many actions per random node are taken and their degree.
            iii) The list of actions taken.
        h) After Pushing all action it will go to sleep for 2 minutes.
        i) Wakeup and repeat from step b.
    
    2) pushUpdate: (25 such threads)
        a) All the new action in shared queue with userSimulator thread of nodes would be pushed to Feed Queue of all its neighbors.
        "Will use locks while dequeueing" <-> L1
        "Will use locks while pushing to feed queue?" <-> log2
        b) log to sns.log and print on terminal 
    
    3) readPost: (10 such threads)
        a) Simply Dequeue from the feed thread and log and print it as mentioned.
        b) If value = 1 i.e. chronologically then print in increasing order of time.
        c) If value = 0 i.e. priority. which is decided on the number of common neighbors of the poster node to the reader node. (Would be precomputed just use this value).
        


Structures:
1) Action: {user_id,action_id,action_type,timestamp(action time)}
    a) NOTE: can be changed, so do update if changed.
    b) user_id: is node number in Graph
    c) action_id: counter variable (keeps on incrementing with every new action)
    d) action_type: is to determine what it was Post, Comment, Like.
    e) timestamp: Unix timestamp
